        

;*************************************************************
ISTORERR:
	rcall   DOTS
	call    XSQUOTE
	.db     3,"AD?"
	call    TYPE
	rjmp    ABORT


; Coded for max 256 byte pagesize !
;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibaseh != iaddrh)(ibaseu != iaddru)
;   if (idirty)
;       writebuffer_to_imem
;   endif
;   fillbuffer_from_imem
;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
;   ibasehi = iaddrhi
;endif
IUPDATEBUF:
	      sub_pflash_tos
XUPDATEBUF:
        sts     iaddrl, tosl
        sts     iaddrh, tosh
        cpi     tosh, high(FLASH_HI-PFLASH+1) ; Dont allow kernel writes
        brcc    ISTORERR
XUPDATEBUF2:	
        lds     t0, iaddrl
        andi    t0, ~(PAGESIZEB-1)
        cpse    t0, ibasel
        rjmp    IFILL_BUFFER
        lds     t0, iaddrh
        cpse    t0, ibaseh
        rjmp    IFILL_BUFFER
        ret

IFILL_BUFFER:
        rcall   IFLUSH
        lds     t0, iaddrl
        andi    t0, ~(PAGESIZEB-1)
        mov     ibasel, t0
        lds     ibaseh, iaddrh
IFILL_BUFFER_1:
        ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
        movw    zl, ibasel
        ldi     xl, low(ibuf)
        ldi     xh, high(ibuf)
IFILL_BUFFER_2:
        lpm_    t1, z+
        st      x+, t1
        dec     t0
        brne    IFILL_BUFFER_2
        ret

IWRITE_BUFFER:
.if OPERATOR_UART == 0
.if U0FC_TYPE == 1
        rcall   DOLIT
        .dw     XOFF
        call    EMIT
.endif
.if U0FC_TYPE == 2
        sbi_    U0RTS_PORT, U0RTS_BIT
.endif
.else  ;; UART1
.if U1FC_TYPE == 1
        rcall   DOLIT
        .dw     XOFF
        call    EMIT
.endif
.if U1FC_TYPE == 2
        sbi_    U1RTS_PORT, U1RTS_BIT
.endif
.endif
        rcall   DOLIT
        .dw     10
        rcall   MS

        ; Disable interrupts
        cli
        movw    zl, ibasel
        cpi     zh, high(FLASH_HI-PFLASH+1) ; Don't allow kernel writes
        brcc    ISTORERR2

        ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
        rcall   DO_SPM
        ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
        rcall   DO_SPM

        ; transfer data from RAM to Flash page buffer
        ldi     t0, low(PAGESIZEB);init loop variable
        ldi     xl, low(ibuf)
        ldi     xh, high(ibuf)
        push    r0
        push    r1
IWRITE_BUFFER1:
        ld      r0, x+
        ld      r1, x+
        ldi     t1, (1<<SPMEN)
        rcall   DO_SPM
        adiw    zl, 2
        subi    t0, 2
        brne    IWRITE_BUFFER1

        ; execute page write
        subi    zl, low(PAGESIZEB) ;restore pointer
        sbci    zh, high(PAGESIZEB)
        ldi     t1, (1<<PGWRT) | (1<<SPMEN)
        rcall   DO_SPM
        ; re-enable the RWW section
        rcall   IWRITE_BUFFER3

        ; read back and check, optional
        ldi     t0, low(PAGESIZEB);init loop variable
        subi    xl, low(PAGESIZEB) ;restore pointer
        sbci    xh, high(PAGESIZEB)
IWRITE_BUFFER2:
        lpm_    r0, z+
        ld      r1, x+
        cpse    r0, r1
        rjmp    WARM_     ; reset
        subi    t0, 1
        brne    IWRITE_BUFFER2
        pop     r1
        pop     r0
ISTORERR2:
	ser     t0
	mov     ibaseh, t0
        cbr     FLAGS1, (1<<idirty)
        // reenable interrupts
        sei
.if OPERATOR_UART == 0
.if U0FC_TYPE == 1
        rcall   DOLIT
        .dw     XON
        call    EMIT
.endif
.if U0FC_TYPE == 2
        cbi_    U0RTS_PORT, U0RTS_BIT
.endif
.else
.if U1FC_TYPE == 1
        rcall   DOLIT
        .dw     XON
        call    EMIT
.endif
.if U1FC_TYPE == 2
        cbi_    U1RTS_PORT, U1RTS_BIT
.endif
.endif
.if DEBUG_FLASH == 1
        rcall   DOLIT
        .dw     'F'
        call    EMIT
.endif
         ret
        ; ret to RWW section
        ; verify that RWW section is safe to read
IWRITE_BUFFER3:
        in_     t8, SPMCSR
        sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
        ret
        ; re-enable the RWW section
        ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
        rcall   DO_SPM
        rjmp    IWRITE_BUFFER3

DO_SPM:
        in_     t8, SPMCSR
        sbrc    t8, SPMEN
        rjmp    DO_SPM       ; Wait for previous write to complete
        out_    SPMCSR, t1
        spm
        ret

